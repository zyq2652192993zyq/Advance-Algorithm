# 位运算简介及实用技巧（二）：进阶篇(1)

=====   真正强的东西来了！   =====

**二进制中的1有奇数个还是偶数个**
    我们可以用下面的代码来计算一个32位整数的二进制中1的个数的奇偶性，当输入数据的二进制表示里有偶数个数字1时程序输出0，有奇数个则输出1。例如，1314520的二进制101000000111011011000中有9个1，则x=1314520时程序输出1。
`var   i,x,c:longint;begin   readln(x);   c:=0;   for i:=1 to 32 do   begin      c:=c + x and 1;      x:=x shr 1;   end;   writeln( c and 1 );end.`
    但这样的效率并不高，位运算的神奇之处还没有体现出来。
    同样是判断二进制中1的个数的奇偶性，下面这段代码就强了。你能看出这个代码的原理吗？
`var   x:longint;begin   readln(x);   x:=x xor (x shr 1);   x:=x xor (x shr 2);   x:=x xor (x shr 4);   x:=x xor (x shr 8);   x:=x xor (x shr 16);   writeln(x and 1);end.`
    为了说明上面这段代码的原理，我们还是拿1314520出来说事。1314520的二进制为101000000111011011000，第一次异或操作的结果如下：

​    00000000000101000000111011011000
XOR  0000000000010100000011101101100
—————————————
    00000000000111100000100110110100

​    得到的结果是一个新的二进制数，其中右起第i位上的数表示原数中第i和i+1位上有奇数个1还是偶数个1。比如，最右边那个0表示原数末两位有偶数个1，右起第3位上的1就表示原数的这个位置和前一个位置中有奇数个1。对这个数进行第二次异或的结果如下：

​    00000000000111100000100110110100
XOR   000000000001111000001001101101
—————————————
    00000000000110011000101111011001

​    结果里的每个1表示原数的该位置及其前面三个位置中共有奇数个1，每个0就表示原数对应的四个位置上共偶数个1。一直做到第五次异或结束后，得到的二进制数的最末位就表示整个32位数里有多少个1，这就是我们最终想要的答案。

**计算二进制中的1的个数**
    同样假设x是一个32位整数。经过下面五次赋值后，x的值就是原数的二进制表示中数字1的个数。比如，初始时x为1314520（网友抓狂：能不能换一个数啊），那么最后x就变成了9，它表示1314520的二进制中有9个1。
`x := (x and $55555555) + ((x shr 1) and $55555555);x := (x and $33333333) + ((x shr 2) and $33333333);x := (x and $0F0F0F0F) + ((x shr 4) and $0F0F0F0F);x := (x and $00FF00FF) + ((x shr 8) and $00FF00FF);x := (x and $0000FFFF) + ((x shr 16) and $0000FFFF);`
    为了便于解说，我们下面仅说明这个程序是如何对一个8位整数进行处理的。我们拿数字211（我们班某MM的生日）来开刀。211的二进制为11010011。

+—+—+—+—+—+—+—+—+
| 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 |   <—原数
+—+—+—+—+—+—+—+—+
|  1 0  |  0 1  |  0 0  |  1 0  |   <—第一次运算后
+——-+——-+——-+——-+
|    0 0 1 1    |    0 0 1 0    |   <—第二次运算后
+—————+—————+
|        0 0 0 0 0 1 0 1        |   <—第三次运算后，得数为5
+——————————-+

​    整个程序是一个分治的思想。第一次我们把每相邻的两位加起来，得到每两位里1的个数，比如前两位10就表示原数的前两位有2个1。第二次我们继续两两相加，10+01=11，00+10=10，得到的结果是00110010，它表示原数前4位有3个1，末4位有2个1。最后一次我们把0011和0010加起来，得到的就是整个二进制中1的个数。程序中巧妙地使用取位和右移，比如第二行中$33333333的二进制为00110011001100….，用它和x做and运算就相当于以2为单位间隔取数。shr的作用就是让加法运算的相同数位对齐。

**二分查找32位整数的前导0个数**
    这里用的C语言，我直接Copy的Hacker's Delight上的代码。这段代码写成C要好看些，写成Pascal的话会出现很多begin和end，搞得代码很难看。程序思想是二分查找，应该很简单，我就不细说了。
`int nlz(unsigned x){   int n;`

```

```

`   if (x == 0) return(32);   n = 1;   if ((x >> 16) == 0) {n = n +16; x = x <<16;}   if ((x >> 24) == 0) {n = n + 8; x = x << 8;}   if ((x >> 28) == 0) {n = n + 4; x = x << 4;}   if ((x >> 30) == 0) {n = n + 2; x = x << 2;}   n = n - (x >> 31);   return n;}`

**只用位运算来取绝对值**
    这是一个非常有趣的问题。大家先自己想想吧，Ctrl+A显示答案。
    答案：假设x为32位整数，则x xor (not (x shr 31) + 1) + x shr 31的结果是x的绝对值
    x shr 31是二进制的最高位，它用来表示x的符号。如果它为0（x为正），则not (x shr 31) + 1等于$00000000，异或任何数结果都不变；如果最高位为1（x为负），则not (x shr 31) + 1等于$FFFFFFFF，x异或它相当于所有数位取反，异或完后再加一。

**高低位交换**
    [这个题](http://www.vijos.cn/Problem_Show.asp?id=1201)实际上是我出的，做为学校内部NOIp模拟赛的第一题。题目是这样：

> ​    给出一个小于2^32的正整数。这个数可以用一个32位的二进制数表示（不足32位用0补足）。我们称这个二进制数的前16位为“高位”，后16位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。
>
> 
>
> 　　例如，数1314520用二进制表示为0000 0000 0001 0100 0000 1110 1101 1000（添加了11个前导0补足为32位），其中前16位为高位，即0000 0000 0001 0100；后16位为低位，即0000 1110 1101 1000。将它的高低位进行交换，我们得到了一个新的二进制数0000 1110 1101 1000 0000 0000 0001 0100。它即是十进制的249036820。
>
> 

​    当时几乎没有人想到用一句位操作来代替冗长的程序。使用位运算的话两句话就完了。
`var   n:dword;begin   readln( n );   writeln( (n shr 16) or (n  shl 16) );end.`
    而事实上，Pascal有一个系统函数swap直接就可以用。

**二进制逆序**
    下面的程序读入一个32位整数并输