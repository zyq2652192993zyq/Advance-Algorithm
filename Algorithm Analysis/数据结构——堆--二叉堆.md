> # 数据结构——优先级队列

二叉堆是一种数组对象，可以视为一棵完全二叉树，根据完全二叉树的性质，假设完全二叉树的节点总数为`n`，下标从1开始计数，假设当前节点为`i`，那么其左右子节点的下标（不超过`n`）为`2 * i`和`2 * i + 1`。

二叉堆（假设是“大根堆”）的一个很重要的性质就是其根节点的数值不小于其子节点的数值。如果是不超过的情况，那么就是“小根堆”。

# `push`操作

`push`操作是指往堆中加入一个元素（以实现小根堆为例），算法如下：

1. 首先在数组末尾增加一个元素，并把这个位置设为当前节点

2. 比较当前节点和它父节点的数值

   * 如果小于父节点，交换数值，并把父节点设为当前节点，转2

   * 如果大于等于父节点，转3

3. 程序结束

可以看出，插入一个节点的时间复杂度是$O(\log n)$。

```c++
vector<int> heap(1e6);
int heap_size;

//实现小根堆
void push(int value)
{
	heap[++heap_size] = value;
	int cur = heap_size, parent;

	while (cur > 1) {
		parent = (cur >> 1);
		if (heap[cur] < heap[parent]) {
			std::swap(heap[cur], heap[parent]);
			cur = parent;
		}
		else break;
	}
}
```

# `top`操作

`top`操作是取出堆的根节点的数值（假设堆非空），也就是取出下标为1的节点的数值，时间复杂度是$O(1)$。

```c++
vector<int> heap(1e6);
int heap_size;

int top()
{
    if (!heap_size) return -1; //堆为空
    return heap[1];
}
```

# `pop`操作

`pop`操作是删除根节点，算法如下：

1. 把堆的最后一个节点放到根的位置，堆的长度减一
2. 根节点设为当前节点`cur`
3. 如果当前节点无儿子，转5；否则把两个（或一个）子节点中数值最小的那个设为当前节点的子节点`child`
4. 比较`cur`和`child`的数值，如果`cur`小于等于`child`，转5；否则交换两个节点数值，把子节点设为当前节点，转3
5. 程序结束

可以看出，删除根节点的时间复杂度是$O(\log n)$。

```c++
vector<int> heap(1e6);
int heap_size;

//实现小根堆
void pop()
{
	if (!heap_size) return; //堆为空

	heap[1] = heap[heap_size];
	--heap_size;

	int cur = 1;
	while (cur * 2<= heap_size) {
		int child = (cur << 1);
		if (child < heap_size && heap[child + 1] < heap[child]) ++child;
		if (heap[cur] <= heap[child]) break;
		std::swap(heap[cur], heap[child]);
		cur = child;
	}
}
```

# 自定义比较函数

**第一种方法**

定义一个结构体，在结构体里将比较运算符重载。

```c++
struct Node {
    int val;
    int pos;
  	bool operator<(const Node & obj) const
    {
        return val < obj.val || (val == obj.val && pos < obj.pos);
    }
};

priority_queue<Node, vector<Node>, greater<Node>> pq;
```

**第二种方法**

优先级队列中，常常需要自定义比较函数，如果已经给定了比较函数并且无法修改，可以使用新特性`decltype`来解决，以及`lambda`函数。

```c++
auto cmp = [] (ListNode *l1, ListNode *l2) {
    return l1 -> val > l2 -> val;
};

priority_queue<ListNode*, vector<ListNode *>, decltype(cmp)> pq(cmp);
```



# 典型题目

- [x] POJ 1862 Stripies（优先级队列，Huffman思想）
- [x] LeetCode 23 合并K个排序链表  （优先级队列优化）
- [x] POJ 2010 Moo University - Financial Aid（优先级队列）
- [x] POJ 3614 Sunscreen（优先级队列）
- [x] POJ 2431 Expedition（优先级队列）
- [x] POJ 3253 Fence Repair（优先级队列）
- [x] 洛谷-P1323 删数问题（基础贪心 + 优先级队列生成集合）
- [x] 一本通-1333：【例2-2】Blah数集（优先级队列模拟）

