> # 动态规划-背包问题

参考资料：

崔添翼——背包九讲

背包问题整理 <https://www.jianshu.com/p/224062fb6ce5>

完全背包<https://blog.csdn.net/u013480600/article/category/2656071>

01背包<https://blog.csdn.net/u013480600/article/category/2160339>

多重背包<https://blog.csdn.net/u013480600/article/category/2668007>

背包问题变种问题：将数组分成两部分，使得这两部分的和的差最小。

OI wiki的总结（背包DP）：<https://oi-wiki.org/dp/knapsack/>

# 01背包

题面形式：

有$n$个重量和价值分别为$w_i, v_i$的物品，从这些物品中选出总重量不超过$W$的物品，每个物品最多只能选一次，求价值总和最大的方案。进一步思考，如果需要输出方案怎么办？（也就是究竟选了哪些物品）

> 这里需要提一下，并不是题面符合此形式就一定用01背包来求解，要去看数据范围，如果数据范围很大但是n的数量很小，那么可以考虑《挑战程序设计竞赛》折半枚举里面的超大背包问题。

先考虑一下暴力解法：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n = 20, totalWeight = 20;
vector<int> w(n), v(n);

int zeroOnePack(int i, int weightLeft)
{
	int res;
	if (i == n) res = 0; //没有剩余物品了
	else if (weightLeft < w[i]) 
		res = zeroOnePack(i + 1, weightLeft); //剩余容量放不下当前物品，考虑下一个
	else //当前物品可以放下，选和不选都尝试一下
		res = max(zeroOnePack(i + 1, weightLeft), zeroOnePack(i + 1, weightLeft - w[i]) + v[i]);

	return res;
}

int main()
{
	cin >> n >> totalWeight;
	
	for (int i = 0; i < n; ++i) cin >> w[i] >> v[i];
	cout << zeroOnePack(0, totalWeight) << endl;
}
```

这个程序主要是针对POJ 3624的测试数据，即使开的数组大一些也会超时的，因为对于每个物品存在选择和不选择两种情况，那么时间复杂度是$O(2^n)$，优化的办法就是去记录已经计算过的结果，方便下次利用。

程序方面最好在《算法手写代码必备手册》的基础上来完善，解这种问题的关键是先写出**状态转移方程**，用空间复杂度不是很理想的二维数组来存储，然后根据表达式再用一位数组（也就是常说的滚动数组）来进行优化。

状态转移方程的两个关键点：写出完整的表达式，明确表达式参数的意义。

定义状态转移方程$f[i][j]$表示把前$i$个物品放进容量为$j$的背包所能获得的最大价值。
$$
f[i][j]=\max \{f[i-1][j], f[i-1][j-w[i]]+v[i]\}
$$
表达式的含义：

* 第$i$个装不进去，价值为$f[i-1][j]$
* 第$i$个装进去了，价值为$f[i-1][j-w[i]] + v[i]$。

下面的程序针对的都是POJ3624的，HDU2602和此基本上是一模一样的。

```c++
//二维数组存储的版本
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n = 3402, totalWeight = 12880;
vector<int> w(n + 1), v(n + 1);
vector<vector<int>> f(n + 1, vector<int>(totalWeight + 1));

int zeroOnePack()
{
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= totalWeight; ++j) {
			f[i][j] = f[i - 1][j];
			if (j >= w[i]) {
				f[i][j] = max(f[i][j], f[i-1][j - w[i]] + v[i]);
			}
		}
	}
	return f[n][totalWeight];
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> n >> totalWeight;
	
	for (int i = 1; i <= n; ++i) cin >> w[i] >> v[i];
	cout << zeroOnePack() << endl;
}
```

但是上面的程序提交会发现超过内存限制，因为开数组要$N(3403)\times M(12881)$的二维数组， 相比于HDU的题目数据大了很多。所以该考虑一下利用滚动数组进行优化了。
$$
f[i][j]=\max \{f[i-1][j], f[i-1][j-w[i]]+v[i]\}
$$
使用滚动数组的方法并不一定好理解，不妨从数学形式来看，对于$f[i][j]$的求解，始终需要去访问$f[i-1]*$，其中*代表状态转移方程中的两种形式，也就是说，二维的表示可以退化成一维的。即可以用$f[j]$来表示。$f[j] = max(f[j], f[j - boneWeight[i]] + boneValue[i])$，但是需要考虑遍历的顺序。这里是逆序遍历，保证每个物品最多使用一次，如果顺序遍历，则是完全背包问题。

解释一下为什么顺序遍历就会出现可能多次存储的情况，因为要考虑的是针对01背包这一类问题的解法，考虑如果还是顺序遍历，程序的核心代码是：

```c++
vector<int> d(totalWeight + 1, 0);
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= totalWeight; ++j) {
        d[j] = max(d[j], d[j - w[i]] + v[i]);
    }
}
```

所以可能存在$j - 2w[i]\geq0$的情况，所以在计算$d[j-2*w[i]]$对应的值的时候，用到了$d[j - w[i]]$的结果，那么就意味着第$i$个物品被放入了2次，所以违背了题意。逆序的时候，$d[totalWeight]$只与$d[totalWeight], d[totalWeight-w[i]] + v[i]$有关，所以不会存在重复计算的过程。

```c++
//滚动数组优化
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n = 3402, totalWeight = 12880;
vector<int> w(n + 1), v(n + 1);

int zeroOnePack()
{
	vector<int> d(totalWeight + 1, 0);
	for (int i = 1; i <= n; ++i) {
		for (int j = totalWeight; j >= w[i]; --j) {
			d[j] = max(d[j], d[j - w[i]] + v[i]);
		}
	}
	return d[totalWeight];
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n >> totalWeight;
	
	for (int i = 1; i <= n; ++i) cin >> w[i] >> v[i];
	cout << zeroOnePack() << endl;
}
```

典型题目：

- [x] POJ-3264 Charm Bracelet或者洛谷P2871 [USACO07DEC]手链Charm Bracelet，（洛谷的题解是可以参考的）
- [x] HDU-2602 Bone Collector（01背包模板题）
- [x] ALGOSPOT-PACKING（需要输出解决方案的详细信息，输出路径的例子）
- [x] 洛谷P1048（其实题意是没有表达出每株草只能取一次，而是从给的样例看出来的，数据也很水）
- [x] HDU-3496 Watch the movie（二维01背包）
- [ ] POJ 1837 Balance（二维01背包）
- [ ] POJ1948：Triangular Pastures（二维01背包）
- [x] 洛谷P1855 榨取kkksc03（二维01背包）
- [x] POJ 2184 Cow Exhibition（带负数的01背包）
- [ ] POJ-3211 washing clothes
- [ ] HDU-2546 饭卡
- [ ] POJ-1948 Triangular Pastures
- [ ] POJ-1837 Balance​
- [ ] HDU-1864 最大报销额
- [ ] HDU-1203  I need an offer（浮点数01背包）
- [ ] UVA-10130 superSale
- [ ] HDU-4182 judge's response
- [ ] POJ-2923 reclocation
- [ ] POJ-3628 bookshelf
- [ ] HDU-2955 robberies
- [ ] HDU-3466 Proud merchants
- [ ] UVA 624 CD
- [ ] HDU 2639 bone collector II（01背包的第K大问题）
- [ ] UVA 562 dividing coins
- [ ] HDU 2126 buy the souvenirs
- [ ] UVA 12563 jin ge jin qu hao

# 完全背包

题面形式：

有$n$种重量和价值分别为$w_i,v_i$的物品，每种物品数量无限，从这些物品中挑选总重量不超过$W$的物品，求挑选出的物品价值总和的最大值，进一步的，考虑输出价值最大时的方案（输出路径）

典型题目：

- [x] POJ-1384或HDU-1114 Piggy-Bank
- [x] POJ-2063 Investment
- [x] UVA 147 dollars
- [ ] UVA 357 let me count the ways
- [x] HDU 1248 寒冰王座
- [x] POJ 2229 Sumsets（完全背包变形）
- [ ] HDU 3127 WHU girls
- [ ] UVA 10465 Homer Simpson
- [ ] HDU 1284 铅笔兑换问题
- [ ] HDU 2159 FATE
- [ ] POJ 1252 euro efficiency
- [ ] POJ 3181 dollar dayz
- [ ] UVA 10306 e-coins
- [ ] UVA 11137 ingenuous cubrency
- [ ] UVA 674 coin change
- [ ] HDU 4508 湫湫系列故事——减肥记1


# 多重背包

基本模型：有$n$种物品和一个容量为$v$的背包，第$i$种物品最多有$M_i$件，每一件耗费的空间是$C_i$，价值是$W_i$，求如何使价值总和最大。

优化的思路是采用二进制分组来优化。时间复杂度$O(nvlogC)$，其中`n`是物品数量，

- [x] HDU 2191 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活
- [x] HDU 3732 Ahui Writes Word
- [x] POJ 1276 Cash machines
- [x] HDU 2844 Coins(和POJ 1742是一个题目，但是在POJ 会TLE)（在HDU可用多重背包做）
- [x] POJ 1742 Coins（多重背包的存在性问题）
- [ ] HDU-1171 Big Event in HDU
- [ ] HDU 1059 DIVIDING
- [ ] hdu 2844 COINS
- [ ] poj 2392 SPACE ELEVATOR
- [ ] HDU 3591 THE TROUBLE OF XIAOqian
- [ ] POJ 3260 the fewest coins​


# 混合背包

实际上就是上面三种问题的结合，有的只能取一次，有的可以取无限次，有的是k次。

- [ ] HDU 1712 ACboy needs your help
- [x] 洛谷-P1833 樱花 