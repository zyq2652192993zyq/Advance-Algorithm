> # 树——基础二叉树知识点

树是n个结点的有限集合，它或者是空集，或者满足以下条件：

1. 有一个被称为根的结点；
2. 其余结点可分为$m(m \geqslant 0)$个互不相交的集合$T_{1}, T_{2}, \cdots, T_{m}$，这些集合本身也是一棵树，并称它们为根结点的子树.

树中唯一一个没有直接前驱的结点称为**根结点**，**叶结点**也称为终端结点。除根以外的非叶结点也被称为**内部结点**。

一个结点直接后继的数目称为**结点的度**。树中所有结点的度的最大值称为这棵**树的度**。

结点的直接后继称为结点的**子结点**，而结点的直接前驱称为它的**父结点**。在树中，每个结点都存在着唯一的一条到根结点的路径，路径上的所有结点都是该结点的**祖先结点**。**子孙结点**是指该结点的所有子树中的全部结点。也就是说，树中除根之外的所有结点都是根结点的子孙。

结点的层次，也称为**深度**，是从根结点到这个结点所经过的边数。一棵树中结点的最大层次称为**树的高度或深度**。**结点的高度**指的是以该结点为根的子树的高度。

若将树中每个结点的子树看成自左向右有序的，则称该树为**有序树**，否则称为**无序树**。

# 找树根和节点的孩子

- [x] 一本通-1336：【例3-1】找树根和孩子

给定一棵树，输出树的根`root`，孩子最多的结点`max`以及他的孩子。

树的根入度为0，只需用一个二维矩阵统计每个节点的孩子，每个节点对应的数组大小就是孩子的数量。

```c++
#include <bits/stdc++.h>

using namespace std;

int n, m;
vector<vector<int> > grid(105);
vector<int> inDegree(105);

void solve()
{
	int root = -1, node = -1, maxVal = 0;
	for (int i = 1; i <= n; ++i) {
		if (grid[i].size() > maxVal) {
			maxVal = grid[i].size();
			node = i;
		}
		if (inDegree[i] == 0) root = i;
	}

	cout << root << endl;
	cout << node << endl;
	int len = grid[node].size();
	sort(grid[node].begin(), grid[node].end());
	for (int i = 0; i < len; ++i) {
		cout << grid[node][i];
		if (i != len - 1) cout << ' ';
	}
	cout << endl;
}



int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n >> m;
	int from, to;
	for (int i = 0; i < m; ++i) {
		cin >> from >> to;
		grid[from].push_back(to);
		++inDegree[to];
	}
	solve();

	return 0;
}
```

# 二叉树主要性质

* **一颗非空二叉树的第$i$层上最多有$2^{i-1}$的点。**

若使第$i$层的节点个数最多，则$i-1$层必须是每个节点都有两个子节点。采用归纳法，当$i=1$时，显然成立，设当$i=k$时成立，则第$k+1$层节点最多是$k$层的两倍为$2^k$，成立。

* **一颗高度为$k$的二叉树，最多具有$2^{k}-1$个节点。**

满二叉树，相当于求解：
$$
\sum _{i=0} ^{k-1}2^i=2^k-1
$$

* **对于一颗非空二叉树，如果叶节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$。**

证明：设二叉树中度为1的节点个数为$n_1$，节点总个数为$n$则：
$$
n = n_1 + n_2 + n_0
$$
因为二叉树中节点是两两相连，则边（$B$）的数量为：
$$
B = n -1
$$
因为边都是从度为1或2的节点引出，所以有：
$$
B = n_1 + 2n_2
$$
于是有：
$$
n-1=n_1+2n_2
$$
所以联立可得：$n_0=n_2+1$

* **具有$n$个节点的完全二叉树的高度$k=[log_2n] +1$。**

设具有$n$个节点的完全二叉树的高度为$k$，则完全二叉树的前$k-1$层必是满的，所以有$2^{k-1}-1$个节点，则第$k$层最少有一个节点，最多有$2^{k-1}$个节点，所以有不等式：
$$
2^{k-1} -1 < n \leq 2^k-1\\
k-1 \leq log_2n < k\\
log_2n <k \leq log_2n+1 \\
k = [log_2n]+1
$$

* **如果有一颗$n$个节点的完全二叉树中的节点按层自上而下（第一层到$[log_2n]+1$层），每一层自左向右编号，设根节点的编号是1，则对任意一个编号为$i$的节点（$1\leq i \leq n$），有：**
  * 如果$i=1$，则该节点是二叉树的根节点，如果$i > 1$则其父节点的编号是$[i/2]$
  * 如果$2i > n$，则编号为$i$的结点为叶节点，没有儿子（注意完全二叉树的限制），否则左儿子的编号$2i$
  * 如果$2i+1>n$，则编号为$i$的结点没有右儿子，否则右儿子的编号是$2i+1$。

# 扩展二叉树

先序、中序和后序序列中的任何一个都不能唯一确定一棵二叉树，采用`.`对空节点进行补齐，把这样处理的二叉树称为扩展二叉树。扩展二叉树的先序和后序序列能唯一确定其二叉树。

现给出扩展二叉树的先序序列，输出中序和后序序列。

- [ ] 一本通-



# 普通树转二叉树



# 树的计数问题



