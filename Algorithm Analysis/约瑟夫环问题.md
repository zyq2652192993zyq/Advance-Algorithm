# 约瑟夫环问题

> 有$n$个人围成一个圈，每隔$q$个人踢掉一个人，问最后留下来的人是几号？

是不是很熟悉？当初你们刚学的时候怎么做的？是不是用链表？是不是写得痛不欲生，还超时了？哦不是那算了。

如果用链表暴力求解的话，时间复杂度是$O(n)$，但是用我下面的方法，可以加速到 $O(log n)$。

下面我讲一个具体数学课上讲到的简洁解法：

假设初始编号为 $1,2,...,n$，现在考虑一种新的编号方式。

第一个人不会被踢掉，那么他的编号从$n$开始往后加 1 ，变成 $n+1$，然后第二个人编号变为$n+2$ ，直到第 $q$个人，他被踢掉了。

然后第$q+1$个人编号继续加 1 ，变成了$n+q$，依次下去。

考虑当前踢到的人编号为 $kq$，那么此时已经踢掉了 $k$个人，所以接下去的人新的编号为 $n+k(q-1$+1 ...。

所以编号为 $kq+d$人编号变成了 $n+k(q-1) + d$，其中 $1 \leq d \leq q$ 。

直到最后，可以发现活下来的人编号为 $qn$，问题是怎么根据这个编号推出他原来的编号？

以 $n=10, q=3$为例，下图就是每个人新的编号：

<img src="https://pic4.zhimg.com/50/v2-3bf6cc84ae5d9c79a220ddcb326e8bc8_hd.jpg" data-caption="" data-size="normal" data-rawwidth="505" data-rawheight="240" data-default-watermark-src="https://pic4.zhimg.com/50/v2-58b9c18123caa97372798a61f8eb8ac4_hd.jpg" class="origin_image zh-lightbox-thumb" width="505" data-original="https://pic4.zhimg.com/v2-3bf6cc84ae5d9c79a220ddcb326e8bc8_r.jpg"/>![img](F:\Project\ACM-Algorithm\Algorithm Analysis\assets\v2-3bf6cc84ae5d9c79a220ddcb326e8bc8_hd.jpg)

令$N=n+k(q-1)+d$ ，那么他上一次的编号是

$$
k q+d=k q+N-n-k(q-1)=k+N-n
$$

因为
$$
k=\frac{N-n-d}{q-1}=\left\lfloor\frac{N-n-1}{q-1}\right\rfloor
$$
所以上一次编号可以写为
$$
\left\lfloor\frac{N-n-1}{q-1}\right\rfloor+ N-n
$$
因此最后存活的人编号可以用如下的算法计算：

```
N = qn
while N > n:
    N = k + N - n
ans = N
```

其中$k=\left\lfloor\frac{N-n-1}{q-1}\right\rfloor$ 。

如果我们用$D=qn+1-N$ 替代$N$，将会进一步简化算法：
$$
\begin{aligned}
&D=q n+1-N\\
&=q n+1-\left(\left\lfloor\frac{(q n+1-D)-n-1}{q-1}\right\rfloor+ q n+1-D-n\right)\\
&=n+D-\left\lfloor\frac{(q-1) n-D}{q-1}\right\rfloor\\
&=D-\left\lfloor\frac{-D}{q-1}\right\rfloor\\
&=D+\left\lceil\frac{D}{q-1}\right\rceil\\
&=\left\lceil\frac{q}{q-1} D\right\rceil
\end{aligned}
$$
算法伪代码如下：

```
D = 1
while D <= (q-1)n:
    D = k
ans = qn + 1 - D
```

其中$k=\left\lceil\frac{q}{q-1} D\right\rceil$ 。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

LL Ceil(LL x, LL y) {
    return x / y + (x % y != 0);
}

LL J(LL n, LL q) {
    LL D = 1, end = (q - 1) * n;
    while (D <= end) {
        D = Ceil(q * D, q - 1);
    }
    return q * n + 1 - D;
}

int main() {
    LL n, q;
    while (~scanf("%lld%lld", &n, &q)) {
        printf("%lld\n", J(n, q));
    }
    return 0;
}
```

参考资料：

* Wiki OI 约瑟夫问题<https://oi-wiki.org/misc/josephus/>
* CP algorithm
* 知乎<https://www.zhihu.com/question/358255792/answer/974983270>（算法证明需要用到《具体数学》的第八课 取整进阶）​

典型题目：

* [ ] HDU 3089
* [ ] CF 101955 problem K
* [x] SJTU OJ 4089 约瑟夫环（当时用数组模拟的）