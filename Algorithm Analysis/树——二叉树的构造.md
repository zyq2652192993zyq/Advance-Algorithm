> # 树——二叉树的构造

如果是标准的二叉树遍历结果，只要知道中序遍历的结果，搭配任意一个遍历的结果都可以唯一确定的构造一棵二叉树。

# 根据二叉树的前序和中序遍历结果构造二叉树

- [x] Leetcode 105.从前序与中序遍历序列构造二叉树

1. 前序的第一个为根，在中序中找到根的位置。
2. 中序中根的左右两边即为左右子树的中序遍历。同时可知左子树的大小size-left。
3. 前序中根接下来的size-left个是左子树的前序遍历。
4. 由此可以递归处理左右子树。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        std::ios_base::sync_with_stdio(false);
	    cin.tie(NULL);
	    cout.tie(NULL);

        int m = preorder.size(), n = inorder.size();
        return build(0, m, 0, n, preorder, inorder);
    }

    TreeNode *build(int pre_start, int pre_end, int in_start, int in_end, vector<int>& preorder, vector<int>& inorder)
    {
        if (pre_start == pre_end || in_start == in_end) return NULL;

        TreeNode *root = new TreeNode(preorder[pre_start]);
        int pos = in_start;
        for (int i = in_start; i < in_end; ++i) {
            if (inorder[i] == preorder[pre_start]) {
                pos = i; break;
            }
        }
        int leftSize = pos - in_start;

        root -> left = build(pre_start + 1, pre_start + 1 + leftSize, in_start, pos, preorder, inorder);
        root -> right = build(pre_start + 1 + leftSize, pre_end, pos + 1, in_end, preorder, inorder);
        return root;
    }
};
```

- [x] 一本通-1339：【例3-4】求后序遍历

```c++
#include <bits/stdc++.h>

using namespace std;

string preorder, inorder;

struct TreeNode
{
	char ch;
	TreeNode *left, *right;
	TreeNode(char x): ch(x), left(NULL), right(NULL) {}
};

TreeNode *treeBuild(int in_start, int in_end, int pre_start, int pre_end)
{
	if (in_start == in_end || pre_start == pre_end) return NULL;

	TreeNode *root = new TreeNode(preorder[pre_start]); //建立根节点

	int inRootPos = inorder.find(preorder[pre_start]);
	int leftSize = inRootPos - in_start;

	root -> left = treeBuild(in_start, inRootPos, pre_start + 1, pre_start + 1 + leftSize);
	root -> right = treeBuild(inRootPos + 1, in_end, pre_start + 1 + leftSize, pre_end);

	return root;
}

void postorderTraversal(TreeNode *root)
{
	if (!root) return;
	postorderTraversal(root -> left);
	postorderTraversal(root -> right);
	cout << root -> ch;
}

void makeEmpty(TreeNode *&root)
{
	if (root) {
		makeEmpty(root -> left);
		makeEmpty(root -> right);
		delete root;
		root = NULL;
	}
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> preorder >> inorder;

	TreeNode *root = treeBuild(0, inorder.size(), 0, preorder.size());
	postorderTraversal(root);
	makeEmpty(root);

	return 0;
}
```

# 根据二叉树的中序和后序遍历结果构造二叉树

- [x] LeetCode 106.从中序与后序遍历序列构造二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    using Iter = vector<int>::iterator;
    TreeNode* buildTreeFromInAndPost(Iter in_start, Iter in_end, Iter post_start, Iter post_end){
        if(in_start == in_end) return nullptr;
        if(post_start == post_end) return nullptr;

        auto root = new TreeNode(*(post_end - 1));
        auto inRootPos = find(in_start, in_end, *(post_end-1));
        auto rightSzie = distance(inRootPos+1, in_end);

        root -> right = buildTreeFromInAndPost(inRootPos+1, in_end, post_end-1-rightSzie, post_end-1);
        root -> left = buildTreeFromInAndPost(in_start, inRootPos, post_start, post_end - 1 - rightSzie);

        return root;
    }


    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTreeFromInAndPost(inorder.begin(), inorder.end(), postorder.begin(), postorder.end());
    }
};
```

# 根据二叉树的中序和层序遍历结果构造二叉树

- [x] 一本通-1364：二叉树遍历(flist)

层序遍历的每一层的节点都是下一层的根节点，以测试用例为例：

首先根据层序遍历的第一个元素可知，A是根节点，然后在中序遍历里找到A，那么A的左边的元素就是左子树的元素，右边的元素是右子树的元素。这里我们判断左右两边是否存在元素，因为如果不存在元素的话，层序遍历的结果里是不会出现的。更确切的讲，比如A的右边无元素，那么意味着层序遍历的结果里第二层只有B一个元素。

用变量`pos`记录上一个根节点的位置，只需要从根节点往后开始寻找即可，比如到了B，位于左子树，只需要从DBE中查找，因为层序遍历是按照每一层元素出现的先后顺序显示的，那么最先匹配的就是先序遍历的根，所以直接输出即可。

```c++
#include <bits/stdc++.h>

using namespace std;

string inorder, levelorder;
int n;

void solve(int pos, int start, int end)
{
	bool flag = false;
	int j;
	for (int i = pos; i < n; ++i) {
		for (j = start; j <= end; ++j) {
			if (inorder[j] == levelorder[i]) {
				cout << levelorder[i];
				flag = true; break;
			}
		}
		if (flag) break;
	}

	if (start < j) solve(pos + 1, start, j - 1);
	if (j < end) solve(pos + 1, j + 1, end);
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> inorder >> levelorder;
	n = inorder.size();
	solve(0, 0, n - 1);

	return 0;
}
```

# 扩展二叉树

- [x] 一本通-1340：【例3-5】扩展二叉树

由于先序、中序和后序序列中的任一个都不能唯一确定一棵二叉树，所以对二叉树做如下处理，将二叉树的空结点用·补齐，如图所示。我们把这样处理后的二叉树称为原二叉树的扩展二叉树，扩展二叉树的先序和后序序列能唯一确定其二叉树。

![img](http://ybt.ssoier.cn:8088/pic/1340.gif)

现给出扩展二叉树的先序序列，要求输出其中序和后序序列。

```c++
#include <bits/stdc++.h>

using namespace std;

class Tree
{
	struct TreeNode {
		char ch;
		TreeNode *left, *right;
		TreeNode(char x): ch(x), left(NULL), right(NULL) {}
	};
	TreeNode *root;
	int pos;

	void build(const string & s, TreeNode *& root)
	{
		if (s[++pos] != '.') {
			root = new TreeNode(s[pos]);
			build(s, root -> left);
			build(s, root -> right);
		}
		else root = NULL;
	}

	void inorderTraversal(TreeNode *root)
	{
		if (root) {
			inorderTraversal(root -> left);
			cout << root -> ch;
			inorderTraversal(root -> right);
		}
	}

	void postorderTraversal(TreeNode *root)
	{
		if (root) {
			postorderTraversal(root -> left);
			postorderTraversal(root -> right);
			cout << root -> ch;
		}
	}

	void makeEmpty(TreeNode *& root)
	{
		if (root) {
			makeEmpty(root -> left);
			makeEmpty(root -> right);
			delete root;
			root = NULL;
		}
	}

public:
	Tree(): root(NULL), pos(-1) {}

	~Tree() { makeEmpty(root); }

	void build(const string & s){ build(s, root); }

	void inorderTraversal() { inorderTraversal(root); }
	
	void postorderTraversal() { postorderTraversal(root); }
};


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	string s;
	cin >> s;
	Tree obj;
	obj.build(s);

	obj.inorderTraversal();
	cout << endl;
	obj.postorderTraversal();
	cout << endl;

	return 0;
}
```

# 根据二叉树前序和后序遍历构造二叉树

之前结论已经指明，必须有中序遍历结果才能唯一确定一棵二叉树，现在回到它的逆问题，也就是给出前序和后序遍历结果，问能否构造出一棵这样的二叉树。

- [x] LeetCode 889.根据前序和后序遍历构造二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
        std::ios_base::sync_with_stdio(false);
	    cin.tie(NULL);
	    cout.tie(NULL);

        int n = pre.size();
        return build(0, n - 1, 0, n - 1, pre, post);
    }

    TreeNode *build(int pre_start, int pre_end, int post_start, int post_end, vector<int>& pre, vector<int>& post)
    {
        if (pre_start > pre_end || post_start > post_end) return NULL;

        TreeNode *root = new TreeNode(pre[pre_start]);
        TreeNode *l = NULL, *r = NULL;

        int pos = -1, leftSize = 0;
        if (pre_start < pre_end) {
            pos = find(post.begin(), post.end(), pre[pre_start + 1]) - post.begin();
            leftSize = pos - post_start + 1;
            l = build(pre_start + 1, pre_start + leftSize, post_start, post_start + leftSize - 1, pre, post);
        }

        if (pre_start + leftSize < pre_end) {
            r = build(pre_start + 1 + leftSize, pre_end, post_start + leftSize, post_end - 1, pre, post);
        }

        root -> left = l;
        root -> right = r;
        return root;
    }
};
```

以题目中的数据为例：

```
pre:  1 2 4 5 3 6 7
post: 4 5 2 6 7 3 1

根据前面利用中序和前序来构建二叉树的思路，我们希望得到如下结构
pre: [root][leftSize][rightSize]
post:[leftSize][rightSize][root]

于是思路是首先根据pre的第一个节点构建根节点，然后去判断leftSize是否不为0，如果不为0，那么就可以递归的去构建左子树。

在post里寻找leftSize的第一个元素，那么从post_start到这个元素之间就是左子树的元素
注意每次都要去检查leftSize和rightSize是否存在，不存在则节点为NULL
```

# 根据二叉树的前序遍历构造二叉搜索树

- [x] LeetCode 1008.先序遍历构造二叉树

二叉树没有限定子节点和根节点元素的大小关系，但是二叉搜索树因为限定了大小关系，所以仅仅给出其一个遍历结果，也能唯一确定的构造一个二叉树，只不过是二叉搜索树。

比如题目里的`[8,5,1,7,10,12]`，会发现10，12肯定在右子树，那么就很类似将链表转为二叉树的操作，找到第一个大于起始节点的值，然后递归的去实现，只需要注意一下边界条件即可。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int n = preorder.size();
        if (!n) return NULL;
        return build(preorder, 0, n - 1);
    }

    TreeNode *build(vector<int> & preorder, int start, int end)
    {
        TreeNode *root = new TreeNode(preorder[start]);
        int pos = start;
        while (pos <= end) {
            if (preorder[pos] > preorder[start]) break;
            else ++pos;
        }

        TreeNode *left = NULL, *right = NULL;
        if (pos - 1 - start > 0) left = build(preorder, start + 1, pos - 1);
        if (end - pos + 1 > 0) right = build(preorder, pos, end);
        root -> left = left;
        root -> right = right;

        return root;
    }
};
```



