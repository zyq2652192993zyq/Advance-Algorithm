> # 基础算法——贪心

第一次遇到这个问题是在《挑战程序设计竞赛》的2.2.4节的贪心问题`POJ 3069`，这个问题适合和之前总结的《区间求并集、交集和差集》两部分结合起来看，因为题目背景较为类似，但是方法却是千差万别，所以尽量不要套模板，多从问题本身入手分析。

参考的资料：

* <https://www.cnblogs.com/zeze/p/summer1214.html>
* 周小博 《浅谈信息学竞赛中的区间问题》

典型题目：

- [ ] POJ 1328 区间选点问题
- [ ] 区间相交问题（贪心入门） <https://blog.csdn.net/shao824714565/article/details/51878926>

总结下来的问题（区间贪心）<https://blog.csdn.net/a1097304791/article/details/83306758>

1. **固定长度区间选最多的不重叠区间个数**

n个区间，选择尽量多个区间，使得这些区间两两不相交。（实际上就是抽象版的区间调度问题）

核心思路：

右端点排序（<），再从左到右遇到不相交的就选

核心代码：

```c++
vector<pair<int, int>> job(n);
int res = 0, t = 0;
sort(job.begin(), job.end());
for (int i = 0; i < n; ++i) {
    if (t < job[i].second) {
        ++res;
        t = job[i].first;
    }
}
cout << res << endl;
```

在构建`pair`的时候使用了一个小技巧，因为目标是让先结束的任务排在前面，所以键选择结束时间，而值选择任务开始时间。用变量`t`来代表上一个选取的任务的结束时间，如果遍历数组`job`，发现下一个对象的开始时间大于`t`，则说明这个任务可选，并且一定是后面所有可选任务里面最先结束的（因为之前排序的原因）

典型题目：

- [x] 《挑战程序设计竞赛》2.2.2 区间问题 => 固定长度区间选最多的不重叠区间个数
- [ ] URAL 1099 Work Scheduling (virtual judge上可做)
- [ ] P2949 [USACO09OPEN]工作调度Work Scheduling （来源于OI Wiki的总结）

2. **选点覆盖坐标值**

n个坐标值，每个点左右可以覆盖一定的范围，选择尽量少的点覆盖所有的坐标值。这种题目也可能伪装成区间覆盖问题，比如：

```
设x1 , x2,... , xn是实直线上的n个点。用固定长度的闭区间覆盖这n个点，至少需要多少个这样的固定长度闭区间?设计解此问题的有效算法，并证明算法的正确性。
```

核心思路：

对于输入的坐标值序列先排序，然后找第一个没有被标记的点，以此开始，去寻找最有一个小于`当前坐标+覆盖范围`的点，这个点作为标记点，然后找下一个不在覆盖范围内的点，作为新的起点，循环直到序列结束。

核心代码：

```c++
sort(sequence.begin(), sequence.begin() + n);
int mark()
{
    int cnt = 0;
    int pos = 0;
    while (true) {
        int target = sequence[pos] + range; //下面去寻找最后一个不大于目标值的数
        while (pos < n && sequence[pos] <= target) {++pos;}
        ++cnt;
        if (pos >= n) break;
        pos = pos - 1;
        target = sequence[pos] + range; //寻找第一个大于目标值的数
        while (pos < n && sequence[pos] <= target) {++pos;}
        if (pos >= n) break;
    }

    return cnt;
}
```

典型题目：

- [x] POJ 3069 Saruman's Army

3. **区间覆盖**

数轴上有n个闭区间[ai,bi]，选择尽量少的区间覆盖一条指定的线段[s,t]

左端点排序（<）兼顾右端点（<），每次选择从当前起点能覆盖到的最长的区间

典型题目：

- [x] POJ 2376 Cleaning Shifts（区间长度固定，用最少重叠区间覆盖）
- [ ] POJ 1089
- [ ] ECNU [区间覆盖](https://acm.ecnu.edu.cn/contest/40/problem/R/)
- [ ] HDU 1050 Moving Tables
- [ ] HDU 3397

4. **区间选点**

```
数轴上有N个闭区间[Ai, Bi]。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）。
```

5. **区间划分**

```
时间轴上有n个开区间(ai, bi)，把这些区间至少划分成多少个集合，使得每个集合中的区间两两没有公共点。因为是开区间，所以(1, 2)和(2,3)可在一个集合中
```

