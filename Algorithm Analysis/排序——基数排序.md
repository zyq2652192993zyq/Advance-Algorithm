> # 排序——基数排序

![](F:\Project\LeetCode\img\基数排序-1.png)

![](F:\Project\LeetCode\img\基数排序-2.png)

```c++
#include <bits/stdc++.h>

using namespace std;

int n;
vector<int> seq(1005);
vector<queue<int> > digitQueue(10);

ostream & operator<<(ostream & os, const vector<int> & v)
{
	for (int i = 0; i < n; ++i) {
		os << v[i] << ' ';
	}
	os << endl;

	return os;
}

//根据数字的除以power后的最后一位分桶
void distribute(int power)
{
	for (int i = 0; i < n; ++i) {
		digitQueue[seq[i] / power % 10].push(seq[i]);
	}
}

//将桶内的数字写回原序列
void collect()
{
	int cnt = 0;
	for (int i = 0; i < 10; ++i) {
		while (!digitQueue[i].empty()) {
			seq[cnt++] = digitQueue[i].front();
			digitQueue[i].pop();
		}
	}
}

//基数排序
void radixSort(int d)
{
	int power = 1;
	for (int i = 0; i < d; ++i) {
		distribute(power);
		collect();
		power *= 10;
	}
}

//计算输入的数字的位数
inline int digitCount(int number)
{
	int cnt = 0;
	while (number) {
		number /= 10;
		++cnt;
	}

	return cnt;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n;
	int d = 0;
	for (int i = 0; i < n; ++i) {
		cin >> seq[i];
		d = max(d, digitCount(seq[i]));
	}
	radixSort(d);
	cout << seq;

	return 0;
}
```

```
//测试数据
10
9 66 333 8 55 222 7 44 111 0
```

两个关键的步骤，分桶`distribute`，和收集过程`collect`，额外需要一个`digitCount`来统计数字的位数。