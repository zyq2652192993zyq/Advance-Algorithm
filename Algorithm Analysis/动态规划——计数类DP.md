> # 动态规划——计数类DP

# 划分数

## 集合必须非空

《一本通——基础篇》将此类问题归结为递归，但是显然递归的性能不是很好，因为会存在很多重复的计算，所以将其归为计数类DP。

设$S$是一个具有$n$个元素的集合，$S={a_1, a_2, \cdots, a_n}$，现在将$S$划分成$k$个满足谢列条件的子集合$S_1,S_2,\cdots,S_k$，且满足：
$$
1. Si \neq \varnothing \\
2. Si \cap \mathrm{Sj}=\varnothing \quad(1<=\mathrm{i}, \mathrm{j}<=\mathrm{k} \quad \text { i } \neq \mathrm{j}) \\
3. \mathrm{S} 1 \cup \mathrm{S} 2 \cup \mathrm{S} 3 \cup \cdots \cup \mathrm{S} k=\mathrm{S} \\
$$
也就是将集合$S$中的$n$个元素放入$k$个无标号的盒子里，没有盒子是空的，确定划分数$\mathrm{S}(n,k)$。

求划分数$\mathrm{S}(n,k)$，可以考虑元素$a_n$，前面的`n-1`个元素已经分成了`k`组，那么它需要选择一个加进去，有`k`种选择；前面的`n-1`个元素分成了`k-1`组，$a_n$单独一组，所以可以写成：
$$
\mathrm{S}(n,k) = \mathrm{S}(n-1,k-1) + k\times\mathrm{S}(n-1,k) \quad (n > k, k > 0) \\
\mathrm{S}(n,k) = 0 \quad (n < k或 k = 0)\\
\mathrm{S}(n,k) = 1 \quad (k = 1或k = n)
$$
考虑到只需要计算`k-1`和`k`的情况，所以可以只申请`2n`的空间即可，用两个一维数组来保存计算的结果。

典型题目如 一本通-1315：【例4.5】集合的划分

## 允许集合为空

**这道题还可以通过母函数去做。**

最早在《挑战程序设计竞赛》里面遇到这类问题，典型题目就是 POJ 1644 放苹果。典型题面：

把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？

用$d[i][j]$表示把$j$划分成**不超过**$i$组的结果，那么最终我们需要的结果是$d[n][m]$，然后去寻找状态转移方程。考虑$n$的$m$划分$a_i(\sum_{i=1}^m a_i = n)$，如果对于每一项$\{a_i - 1\}$都大于0，那么相当于$n-m$的$m$划分，如果存在$a_i = 0$，那么相当于$n$的$m-1$划分。所以得到状态转移方程：
$$
d[i][j] = d[i][j-i] + d[i -1 ][j]
$$

# 多重集合组合数

典型题目如POJ 3046 Ant Counting，比如一个序列，可能存在重复的数字，比如{1,1,2,2,3}，划分的可能为：

```
3 sets with 1 ant: {1} {2} {3}

5 sets with 2 ants: {1,1} {1,2} {1,3} {2,2} {2,3}

5 sets with 3 ants: {1,1,2} {1,1,3} {1,2,2} {1,2,3} {2,2,3}

3 sets with 4 ants: {1,2,2,3} {1,1,2,2} {1,1,2,3}

1 set with 5 ants: {1,1,2,2,3}
```

用$d[i][j]$表示从前$i$种物品中取出$j$个的组合数，可以先从前$i-1$种物品取出$j-k$个，再从第$i$种物品取出$k$个添加进来，则状态转移方程是：
$$
d[i][j] = \sum_{k =0}^{\min(j, a[i])} d[i-1][j - k] \\
if : j \leq a_i \\
d[i][j] = \sum_{k=0}^{j} d[i-1][j - k] = d[i-1][0] +d[i-1][1]+\cdots +d[i-1][j] \\
= d[i-1][j] + \sum_{k = 0} ^{j - 1} d[i-1][j - 1 - k] \\
= d[i - 1][j] + d[i][j - 1] \\
if: j > a_i \\
d[i][j] = \sum_{k=0}^{a_i} d[i-1][j - k] \\
= d[i-1][j] + d[i-1][j - 1] + \cdots + d[i-1][j -a_i]  + d[i-1][j-1-a_i] - d[i-1][j-1-a_i]\\
= d[i-1][j]- d[i-1][j-1-a_i] + \sum_{k = 0}^{a_i} d[i-1][j - 1 -k]\\
= d[i-1][j]- d[i-1][j-1-a_i] + d[i][j-1]
$$




/典型题目：

- [x] 《挑战程序设计竞赛》的划分数类型问题
- [ ] CodeForces 559 C Gerald and Giant Chess（来自《算法竞赛进阶指南》）
- [ ] POJ 1737 Connected Graph（来自《算法竞赛进阶指南》）
- [ ] POJ 1037 A Decorative Fence（来自《算法竞赛进阶指南》）
- [x] POJ 1664 放苹果（划分数模板）
- [x] 一本通-1192：放苹果（划分数模板）
- [x] POJ 3181 Dollar Dayz（划分数+高精度）
- [x] CodeForces 451E(多重集合组合数)
- [x] POJ 3046 Ant Counting（多重集合组合数模板题）
- [ ] 洛谷-P5748 集合划分计数（多重集合组合数）
- [x] 一本通-1315：【例4.5】集合的划分

