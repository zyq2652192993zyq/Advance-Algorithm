> # 字符串算法-后缀数组

参考资料

算法合集之《后缀数组——处理字符串的有力工具》

后缀数组就是把一个文本串的所有后缀按字典序从小到大排放的数组。详细介绍见刘汝佳《算法竞赛训练指南》。

         AC自动机可以处理多模板的文本匹配问题，而后缀数组也可以处理多模板的文本匹配问题。那么它们有什么区别呢？

         AC自动机需要事先知道所有的模板，然后对于一个(在线输入的)文本串进行多模板匹配，也就是说模板一定要全部事先知道，需要匹配的文本可以动态的输入。

         后缀数组需要事先知道整个文本串，模板可以一个一个的动态输入。在实际应用中，你很多时候是无法事先知道要查询的模板的(如搜索引擎)。假设你要查找一篇(或多篇)文章里面有没有出现一个词组(模板)，你可以先预处理该文本，计算出它的后缀数组，然后用你输入的这个词组(模板)，对该文本的后缀数组进行二分查找(因为所有后缀已经按字典序排好)，最终通过O(mlogn)(n为文本长度，m为模板长度,后面还会介绍O(m+logn)时间复杂度的算法)的时间复杂度你可以知道该词组(模板)出现的所有位置。(如果此时用KMP去找匹配点的话，复杂度为O(n+m)，在文本串长度n远大于模板串长度m时代价太高)

<https://www.cnblogs.com/victorique/p/8480093.html>讲的较好。

<https://www.cnblogs.com/thmyl/p/6296648.html>

洛谷模板题：后缀排序。



[诱导排序与 SA-IS 算法](https://riteme.site/blog/2016-6-19/sais.html)

SA-IS 是一种在实际运用中相当快速的、线性时间构建字符串的后缀数组的算法。





典型题目

- [ ] POJ 1743Musical Theme(后缀数组)：找不重叠的两个相同子串。
- [ ] POJ 3261Milk Patterns(后缀数组)：找可重叠至少出现K次的子串。
- [ ] SPOJ 694Distinct Substrings(后缀数组)：找字符串的不同子串个数，字符串长<=1000。
- [ ] SPOJ 705New DistinctSubstrings (后缀数组): 找字符串的不同子串个数，字符串长<=50000。
- [ ] URAL1297 Palindrome(最长回文子串:后缀数组)：寻找最长回文子串。
- [ ] POJ 2406Power Strings(后缀数组)：后缀数组做法超时,直接用KMP做更快。
- [ ] POJ 2774Long Long Message(后缀数组:公共子串)：求两个串的最长公共连续子串的长度。
- [ ] URAL1517. Freedom of choice(后缀数组:最长公共连续子串) ：求两个串的最长公共连续子串的长度。
- [ ] POJ 3294Life Forms(后缀数组)：求n个字符串中超过一半字符串中的最长公共连续字串是什么,如果有多解,按字典序输出。
- [ ] SPOJ 220. Relevant Phrases of Annihilation(后缀数组)：给n个串，求在每个串中至少出现2次且不重叠的子串最大长度。

> 主要参考《Algorithm on strings》的第四章

我们定义字符串`string`用符号$y$来表示，长度定义为$|y| = n$，定义$y[i \cdots n-1]$为字符串的后缀，即从下标$i$到字符串末尾，定义空字符串为$\varepsilon$。
$$
k \in Z^{+}, \quad u \in A^{*} \\
\begin{equation}
\text {first}_{k}(u)=\left\{\begin{array}{ll}{u} & {\text { if }|u| \leq k} \\ {u[0 \ldots k-1]} & {\text { otherwise }}\end{array}\right.
\end{equation}
$$
)我们定义一个函数$rank$，来计算按字母表由小到大的顺序，其中对于单个字符串比较无差别，对于一对字符串$(y_1, y_2) \quad (y_1^{'},y_2^{'})$的比较，先比较第一个字符串，再比较第二个字符串。记$R_k[i] = rank(first_k(y[i\cdots n-1]))$，现在我们需要证明一个引理(**Doubling Lemma**)：

$R_{2k}[i]$和$(R_k[i],R_k[i+k])$的值相等。

首先易知$R_k[i]$是$first_k(y[i\cdots n-1])$在所有序列中的一个排序值，从其定义可知能保证不重不漏的覆盖所有序列且严格不等。并且$R_k[i],R_k[i+k]$实际上是对于$R_{2k}[i]$的一个划分，并且一一对应。对于任意的$0 \leq i \ne j < n$，如果$R_{2k}[i] < R_{2k}[j]$， 那么必有$(R_k[i],R_k[i+k]) < (R_k[j],R_k[j+k])$ 。所以显然相等。这也就是后面倍增算法的理论依据。

