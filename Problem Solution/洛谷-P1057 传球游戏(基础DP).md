> # 洛谷-P1057 传球游戏(基础DP)

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m*m*次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1->2->3->1和1->3->2->1，共2种。

## 输入格式

一行，有两个用空格隔开的整数n,m($3 \le n \le 30,1 \le m \le 30$)。

## 输出格式

1个整数，表示符合题意的方法数。

## 输入输出样例

**输入 #1**

```
3 3
```

**输出 #1**

```
2
```

## 说明/提示

* 40%的数据满足：$3 \le n \le 30,1 \le m \le 20$
* 100%的数据满足：$3 \le n \le 30,1 \le m \le 30$
* 2008普及组第三题



用`d[i][j]`表示传球`i`次后求落在标号为`j`的人手里的方法数。求解目标是`d[m][1]`，状态转移方程是：
$$
d[i][j] = d[i - 1][j - 1] + d[i - 1][j + 1]
$$
对于状态转移方程的解释：因为传球只能从相邻的位置传过来，那么标号为`j`的只能从`j-1`和`j+1`转移过来，也就是上一轮球在`j-1`和`j+1`手中。边界条件，注意`j=1`和`j=n`的情况，特殊处理。初始化，`d[1][1] = 1, d[1][n] = 1`。

```c++
#include <bits/stdc++.h>

using namespace std;

int n, m;
vector<vector<int>> d(35, vector<int>(35));

int solve()
{
	d[1][n] = 1, d[1][2] = 1;
	for (int i = 2; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			if (j == 1) d[i][j] = d[i - 1][n] + d[i - 1][2];
			else if (j == n) d[i][j] = d[i - 1][n - 1] + d[i - 1][1];
			else d[i][j] = d[i - 1][j - 1] + d[i - 1][j + 1];
		}
	}

	return d[m][1];
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n >> m;

	cout << solve() << endl;

	return 0;
}
```

时间复杂度$O(mn)$。当然也可以用搜索的方法，但是需要注意剪枝技巧。