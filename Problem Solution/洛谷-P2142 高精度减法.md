> # 洛谷-P2142 高精度减法

## 题目描述

高精度减法

## 输入格式

两个整数a,b（第二个可能比第一个大）

## 输出格式

结果（是负数要输出负号）

## 输入输出样例

## 输入

```
2
1
```

## 输出

```
1
```

----

```c++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> sub(const vector<int> & num1, const vector<int> & num2)
{
	int length = num1.size();
	vector<int> res(length, 0);

	for (int i = 0; i < length - 1; ++i) {
		res[i] += num1[i] - num2[i];
		if (res[i] < 0) {
			res[i + 1] -= 1;
			res[i] += 10;
		}
	}
	res[length - 1] += num1[length - 1] - num2[length - 1];
	reverse(res.begin(), res.end());

	return res;
}

template <typename T>
ostream & operator<<(ostream & os, const vector<T> & v)
{
	size_t i = 0;
    
	while (v[i] == 0) ++i;
	for ( ; i < v.size(); ++i)
		os << v[i];

	return os;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	string str1, str2;
	cin >> str1 >> str2;

	if (str1 == str2) cout << 0;
	else {
		bool flag = true;
		if (str1.size() < str2.size() || (str1.size() == str2.size() && str1 < str2)) {
			std::swap(str1, str2);
			flag = false;
		} 

		int length = max(str1.size(), str2.size());
		vector<int> num1(length, 0), num2(length, 0);

		for (size_t i = 0; i < str1.size(); ++i) num1[str1.size() - 1 - i] = str1[i] - '0';
		for (size_t i = 0; i < str2.size(); ++i) num2[str2.size() - 1 - i] = str2[i] - '0';

		if (flag) cout << sub(num1, num2);
		else cout << "-" << sub(num1, num2);
	}

	return 0;
}
```

这道题看上去和高精度加法类似，但是却布满坑点：

- 两个字符串相减出现前导0，需要除去比如100-99
- 前导0并不是所有都需要除去，比如0-0或100-100
- 两个数相减可能为负，需要在结果前加负号，比较两个数的大小不能直接写成`str1 < str2`，因为比如38和370，按照字符串的比较规则是`38 > 370`，所以需要分为位数不同和位数相同两种情况计算。