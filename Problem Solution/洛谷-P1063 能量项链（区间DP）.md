> # 洛谷 - P1063 能量项链（区间DP）

# 题目描述

在MarsMars星球上，每个MarsMars人都随身佩带着一串能量项链。在项链上有NN颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是MarsMars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为mm，尾标记为rr，后一颗能量珠的头标记为r，尾标记为nn，则聚合后释放的能量为m \times r \times nm×r×n（MarsMars单位），新产生的珠子的头标记为mm，尾标记为nn。

需要时，MarsMars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设N=4N=4，44颗珠子的头标记与尾标记依次为(2,3) (3,5) (5,10) (10,2)(2,3)(3,5)(5,10)(10,2)。我们用记号⊕表示两颗珠子的聚合操作，(jj⊕kk)表示第j,kj,k两颗珠子聚合后所释放的能量。则第44、11两颗珠子聚合后释放的能量为：

(44⊕11)=10 \times 2 \times 3=60=10×2×3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：

((44⊕11)⊕22)⊕33）=10 \times 2 \times 3+10 \times 3 \times 5+10 \times 5 \times 10=71010×2×3+10×3×5+10×5×10=710。

# 输入格式

第一行是一个正整数N(4≤N≤100)N(4≤N≤100)，表示项链上珠子的个数。第二行是NN个用空格隔开的正整数，所有的数均不超过10001000。第ii个数为第ii颗珠子的头标记(1≤i≤N)(1≤i≤N)，当i<Ni<N时，第ii颗珠子的尾标记应该等于第i+1i+1颗珠子的头标记。第NN颗珠子的尾标记应该等于第11颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

# 输出格式

一个正整数E(E≤2.1 \times (10)^9)E(E≤2.1×(10)9)，为一个最优聚合顺序所释放的总能量。

# 样例输入

```
4
2 3 5 10
```

# 样例输出

```
710
```

---

```c++
#include <bits/stdc++.h>

using namespace std;

vector<int> seq(205), preSum(205);
vector<vector<int>> d(205, vector<int>(205, 0));
int n;



int solve()
{
	for (int len = 2; len <= n; ++len) {
		for (int i = 1; i + len - 1 <= 2 * n; ++i) {
			int j = i + len - 1;
			for (int k = i; k < j; ++k) {
				d[i][j] = max(d[i][j], d[i][k] + d[k + 1][j] + seq[i - 1] * seq[k] * seq[j]);
			}
		}
	}

	int res = INT_MIN;
	for (int i = 1; i <= n; ++i) {
		res = max(res, d[i][i + n - 1]);
	}

	return res;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n;
	for (int i = 0; i < n; ++i)  {
		cin >> seq[i];
		seq[i + n] = seq[i];
	}
	seq[2 * n] = seq[0];

	cout << solve() << endl;

	return 0;
}
```

思路和`UVa 348`是一样的，都是区间DP的思想，但是区别在于前者要求最小值，现在是求最大值并且不需要输出路径。所以就是有环的石子合并问题，那么就扩展2倍空间，注意和UVA 348的区别，UVA 348中矩阵乘法最后一个矩阵的列数和第一个矩阵的行数是没有关系的，但是本题里是存在关联的，于是让`seq[n * 2] = seq[0]`，保证了拆分后正确的对应关系。

用`d[i][j]`表示将第`i`个项链到第`j`个项链合并的代价，状态转移方程：
$$
d[i][j] = \max(d[i][j], d[i][k] + d[k+1][j] + \text{seq}[i-1] \times \text{seq}[k] \times \text{seq}[j])
$$
合并代价的对应关系可以通过仅有两个项链的时候来进行对应，实际上和UVA 348的对应关系是一样的。时间复杂度$O(n^3)$。

