> # 洛谷 - P1063 能量项链（区间DP）

# 题目描述

在MarsMars星球上，每个MarsMars人都随身佩带着一串能量项链。在项链上有NN颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是MarsMars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为mm，尾标记为rr，后一颗能量珠的头标记为r，尾标记为nn，则聚合后释放的能量为m \times r \times nm×r×n（MarsMars单位），新产生的珠子的头标记为mm，尾标记为nn。

需要时，MarsMars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设N=4N=4，44颗珠子的头标记与尾标记依次为(2,3) (3,5) (5,10) (10,2)(2,3)(3,5)(5,10)(10,2)。我们用记号⊕表示两颗珠子的聚合操作，(jj⊕kk)表示第j,kj,k两颗珠子聚合后所释放的能量。则第44、11两颗珠子聚合后释放的能量为：

(44⊕11)=10 \times 2 \times 3=60=10×2×3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：

((44⊕11)⊕22)⊕33）=10 \times 2 \times 3+10 \times 3 \times 5+10 \times 5 \times 10=71010×2×3+10×3×5+10×5×10=710。

# 输入格式

第一行是一个正整数N(4≤N≤100)N(4≤N≤100)，表示项链上珠子的个数。第二行是NN个用空格隔开的正整数，所有的数均不超过10001000。第ii个数为第ii颗珠子的头标记(1≤i≤N)(1≤i≤N)，当i<Ni<N时，第ii颗珠子的尾标记应该等于第i+1i+1颗珠子的头标记。第NN颗珠子的尾标记应该等于第11颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

# 输出格式

一个正整数E(E≤2.1 \times (10)^9)E(E≤2.1×(10)9)，为一个最优聚合顺序所释放的总能量。

# 样例输入

```
4
2 3 5 10
```

# 样例输出

```
710
```

---

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 0x0fffffff;
vector<vector<int>> d(105, vector<int>(105, -1));
vector<int> p(105, 0);
int n, caseNum = 1;

int intervalDP(const int a, const int b)
{
    if (d[a][b] != -1) return d[a][b]; //区间段已经计算过
    if (a == b) return d[a][b] = 0;
    //d[a][b] = -INF;
    for (int i = a; i < b; ++i){
        d[a][b] = max(d[a][b], intervalDP(a, i) + intervalDP(i+1, b) + p[a] * p[i + 1] * p[(b + 1) % n]);
     } 

    return d[a][b]; 
}

void init(int n)
{
    fill(d.begin(), d.begin() + n, vector<int>(105, -1));
    int tmp = p[n - 1];
    for (int i = n - 1; i > 0; --i)
        p[i] = p[i - 1];
    p[0] = tmp;
}

int main()
{
    cin >> n;

    for (int i = 0; i < n; ++i)
        cin >> p[i];

    int maxPower = 0;
    while (caseNum++ <= n){
        int result = intervalDP(0, n - 1);
        //cout << result << " " << p[0] << endl;
        maxPower = max(result, maxPower);
        init(n);
    }
    cout << maxPower;

    return 0;
}
```

思路和`UVa 348`是一样的，都是区间DP的思想，但是区别在于前者要求最小值，现在是求最大值并且不需要输出路径。还有一点是前者是固定了顺序，也就是相当于把链拆开固定好了，但是此题需要知道从哪里拆链，由于并不知道，那就需要都探测一遍，所以在`init()`函数里，每次都需要调整一下数值的顺序。另外就是程序18行，由于是首位相连，那么这种思路和幻方问题填数的思路是一致的，所以用`p[(b + 1) % n]`来表示。

