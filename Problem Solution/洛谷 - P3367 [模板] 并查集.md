> # 洛谷 - P3367 [模板] 并查集

## 题目描述

如题，现在有一个并查集，你需要完成合并和查询操作。

## 输入格式

第一行包含两个整数N、M，表示共有N个元素和M个操作。

接下来M行，每行包含三个整数Zi、Xi、Yi

当Zi=1时，将Xi与Yi所在的集合合并

当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N

## 输出格式

如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N

## 输入输出样例

**输入 #1**

```
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4
```

**输出 #1**

```
N
Y
N
Y
```

## 说明/提示

时空限制：1000ms,128M

数据规模：

对于30%的数据，N<=10，M<=20；

对于70%的数据，N<=100，M<=1000；

对于100%的数据，N<=10000，M<=200000。

---

```c++
#include <vector>
#include <iostream>

using namespace std;

class DisjSets
{
  public:
    explicit DisjSets( int numElements ) : s( numElements, -1 ) {}

    // int find( int x ) const
    // {
    //     if( s[ x ] < 0 )
    //         return x;
    //     else
    //         return find( s[ x ] );
    // }

    int find( int x )
    {
        if( s[ x ] < 0 )
            return x;
        else
            return s[ x ] = find( s[ x ] );
    }

    void unionSets( int root1, int root2 )
    {
        if ( s[ root2 ] < s[ root1 ] )  // root2 is deeper
            s[ root1 ] = root2;        // Make root2 new root
        else{
            if( s[ root1 ] == s[ root2 ] )
                --s[ root1 ];          // Update height if same
            s[ root2 ] = root1;        // Make root1 new root
        }
    }

  private:
    vector<int> s;
};

int main( )
{
    int N, M;
    cin >> N >> M;

    DisjSets ds(N);

    while(M--){
        int action, num1, num2;
        cin >> action >> num1 >> num2;

        if (action == 1){
            int s1 = ds.find(num1 - 1);
            int s2 = ds.find(num2 - 1);
            ds.unionSets(s1, s2);
        }
        else{
            if (ds.find(num1 - 1) == ds.find(num2 - 1))
                cout << "Y" << endl;
            else
                cout << "N" << endl;
        }
    }

    return 0;
}
```

算法正确，但是会MLE。