> # HDU-1878 欧拉回路（连通性+偶数度数检验）

# Problem Description

欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？

# Input

测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 < N < 1000 )和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结束。

# Output

每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。

# Sample Input

```
3 3
1 2
1 3
2 3
3 2
1 2
2 3
0
```

# Sample Output

```
1
0
```

---

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int vertexNum, edgeNum;
vector<int> line(1000, 0);
vector<vector<int>> denseGraph(1000, line);
vector<bool> vertexVisited(1000, false);
vector<int> degree(1000, 0);

void DFS(int s)
{
    for (int i = 1; i <= vertexNum; ++i){
        if (!vertexVisited[i] && denseGraph[s][i]){
            vertexVisited[i] = true;
            DFS(i);
        }
    }
}

bool connectCheck()
{
    int count = 0;

    for (int i = 1; i <= vertexNum; ++i){
        if (!vertexVisited[i]){
            DFS(i);
            ++count;
        }
    }

    if (count == 1) return true;
    else return false;
}


int main()
{
    while ((cin >> vertexNum) && vertexNum){
        cin >> edgeNum;

        //input process
        for (int i = 1; i <= edgeNum; ++i){
            int point1, point2;
            cin >> point1 >> point2;
            denseGraph[point1][point2] = 1;
            denseGraph[point2][point1] = 1;
            ++degree[point1];
            ++degree[point2];
        }

        //process function
        bool connect = connectCheck();

        bool exist = true;
        for (int i = 1; i <= vertexNum; ++i){
            if (degree[i] % 2 != 0)
                exist = false;
        }

        if (connect && exist) cout << 1 << endl;
        else cout << 0 << endl;

        //reset process
        fill(vertexVisited.begin() + 1, vertexVisited.begin() + 1 + vertexNum, false);
        fill(degree.begin() + 1, degree.begin() + 1 + vertexNum, 0);
        for (int i = 1; i <= vertexNum; ++i)
            fill(denseGraph[i].begin() + 1, denseGraph[i].begin() + 1 + vertexNum, 0);
    }
    
    return 0;
}
```

